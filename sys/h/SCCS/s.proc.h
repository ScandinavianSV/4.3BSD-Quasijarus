h47949
s 00004/00000/00119
d D 7.2 86/10/13 21:43:03 karels 41 40
c merge in tahoe system
e
s 00001/00001/00118
d D 7.1 86/06/04 23:26:14 mckusick 40 39
c 4.3BSD release version
e
s 00000/00001/00119
d D 6.6 86/04/12 13:37:08 karels 39 38
c don't need p1br
e
s 00001/00001/00119
d D 6.5 85/10/28 15:04:10 karels 38 37
c use proper types for uids, gids
e
s 00007/00001/00113
d D 6.4 85/06/08 15:04:12 mckusick 37 36
c Add copyright
e
s 00001/00000/00113
d D 6.3 85/05/05 23:26:43 karels 36 35
c add p_p1br (again)
e
s 00006/00002/00107
d D 6.2 84/06/06 23:10:47 sam 35 33
c check in for mike: add kre's changes for separate lists of 
c free, zombie, and active processes
e
s 00001/00000/00109
d R 6.2 84/05/10 09:39:08 karels 34 33
c add pointer to last used proc slot
e
s 00000/00000/00109
d D 6.1 83/07/29 06:13:28 sam 33 32
c 4.2 distribution
e
s 00000/00003/00109
d D 4.24 83/07/01 02:24:59 root 32 31
c purge #if sun's
e
s 00006/00006/00106
d D 4.23 83/06/02 15:52:29 sam 31 30
c new signals
e
s 00003/00013/00109
d D 4.22 83/05/22 17:22:14 sam 30 29
c purge mush; make quota's permanent
e
s 00003/00000/00119
d D 4.21 83/05/18 02:42:13 sam 29 28
c sun changes
e
s 00001/00001/00118
d D 4.20 83/01/20 17:01:22 sam 28 27
c no more SDLYU (yeah)
e
s 00001/00001/00118
d D 4.19 82/12/09 18:53:47 sam 27 26
c put SOWEUPC back for profil
e
s 00001/00013/00118
d D 4.18 82/11/13 23:08:31 sam 26 25
c merge 4.1b and 4.1c
e
s 00011/00001/00120
d D 4.17 82/10/31 16:27:39 root 25 24
c SPTECHG and u_short p_xstat and QUOTA/MUSH grot
e
s 00004/00001/00117
d D 4.16 82/10/21 17:30:41 root 24 23
c lint
e
s 00001/00002/00117
d D 4.15 82/09/08 08:11:31 root 23 22
c label_t now a structure; other misc changes
e
s 00001/00000/00118
d D 4.14 82/09/06 23:01:17 root 22 21
c more timer stuff
e
s 00008/00039/00110
d D 4.13 82/09/04 09:26:35 root 21 20
c get rid of cruddy exit stuff: use a mbuf
e
s 00003/00000/00146
d D 4.12 82/07/17 22:03:44 kre 20 19
c include mush.h & mu_msg.h (to obtain size of mmsgbuf)
e
s 00029/00022/00117
d D 4.11 82/07/16 16:57:40 kre 19 18
c added new fields for QUOTA & mu_msg + SLOGIN flag
e
s 00001/00001/00138
d D 4.10 82/01/30 19:14:49 wnj 18 17
c remove SDETACH
e
s 00001/00000/00138
d D 4.9 81/10/17 16:14:30 wnj 17 16
c cleanup (mpx removal, old tty removal, beginnings of select)
e
s 00002/00002/00136
d D 4.8 81/04/23 01:24:39 wnj 16 15
c SANOM->SSEQL
e
s 00001/00000/00137
d D 4.7 81/04/13 20:40:02 root 15 14
c add p_maxrss
e
s 00002/00002/00135
d D 4.6 81/03/09 00:27:20 wnj 14 13
c lint
e
s 00002/00001/00135
d D 4.5 81/02/27 00:02:07 wnj 13 12
c move to pointer base to allow dyn allocation
e
s 00000/00006/00136
d D 4.4 81/02/26 04:30:11 wnj 12 11
c cosmetics
e
s 00001/00001/00141
d D 4.3 81/02/19 21:41:51 wnj 11 10
c %G%->%E%
e
s 00001/00000/00141
d D 4.2 81/02/15 20:37:30 wnj 10 9
c ast and hard/soft clock
e
s 00000/00000/00141
d D 4.1 80/11/09 17:01:28 bill 9 8
c stamp for 4bsd
e
s 00002/00002/00139
d D 3.7 80/10/13 09:59:25 bill 8 6
c %cpu stuff
e
s 00001/00001/00140
d R 3.7 80/09/18 00:27:05 bill 7 6
c DETACH->ORPHAN
e
s 00021/00019/00120
d D 3.6 80/07/11 08:24:31 bill 6 5
c define SDETACH and SNUSIG
e
s 00001/00001/00138
d D 3.5 80/06/07 02:59:52 bill 5 4
c %H%->%G%
e
s 00001/00001/00138
d D 3.4 80/05/18 11:39:19 bill 4 3
c s/int/long/ in p->p_sig
e
s 00010/00004/00129
d D 3.3 80/05/15 17:17:52 bill 3 2
c new fields for signals
e
s 00001/00000/00132
d D 3.2 80/04/14 18:26:44 bill 2 1
c added STIMO
e
s 00132/00000/00000
d D 3.1 80/04/09 16:24:59 bill 1 0
c date and time created 80/04/09 16:24:59 by bill
e
u
U
t
T
I 1
D 5
/*	%M%	%I%	%H%	*/
E 5
I 5
D 11
/*	%M%	%I%	%G%	*/
E 11
I 11
D 37
/*	%M%	%I%	%E%	*/
E 37
I 37
/*
D 40
 * Copyright (c) 1982 Regents of the University of California.
E 40
I 40
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 40
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */
E 37
E 11
E 5

I 25
D 26
#ifdef vax		/* GROT */
#ifndef QUOTA
#define	QUOTA		/* GROT */
#endif
#ifndef MUSH
#define	MUSH		/* GROT */
#endif
#endif			/* GROT */

E 25
I 20
#include "mush.h"
#include "mu_msg.h"

E 26
E 20
/*
 * One structure allocated per active
 * process. It contains all data needed
 * about the process while the
 * process may be swapped out.
 * Other per process data (user.h)
 * is swapped with the process.
D 12
 *
 * NB: OFFSETS HERE ARE ALSO DEFINED IN proc.m
E 12
 */
D 21
struct	proc
{
E 21
I 21
struct	proc {
E 21
	struct	proc *p_link;	/* linked list of running processes */
	struct	proc *p_rlink;
I 35
	struct	proc *p_nxt;	/* linked list of allocated proc slots */
	struct	proc **p_prev;		/* also zombies, and free proc's */
E 35
	struct	pte *p_addr;	/* u-area kernel map address */
	char	p_usrpri;	/* user-priority based on p_cpu and p_nice */
	char	p_pri;		/* priority, negative is high */
	char	p_cpu;		/* cpu usage for scheduling */
	char	p_stat;
	char	p_time;		/* resident time for scheduling */
	char	p_nice;		/* nice for cpu usage */
	char	p_slptime;	/* time since last block */
D 3
	int	p_flag;
E 3
I 3
	char	p_cursig;
E 3
D 4
	int	p_sig;		/* signals pending to this process */
E 4
I 4
D 31
	long	p_sig;		/* signals pending to this process */
E 4
D 3
	int	p_ignsig;	/* ignored signals */
E 3
I 3
	long	p_siga0;	/* low bit of 2 bit signal action */
	long	p_siga1;	/* high bit of 2 bit signal action */
#define	p_ignsig p_siga0	/* ignored signal mask */
E 31
I 31
	int	p_sig;		/* signals pending to this process */
	int	p_sigmask;	/* current signal mask */
	int	p_sigignore;	/* signals being ignored */
	int	p_sigcatch;	/* signals being caught by user */
E 31
	int	p_flag;
E 3
D 38
	short	p_uid;		/* user id, used to direct tty signals */
E 38
I 38
	uid_t	p_uid;		/* user id, used to direct tty signals */
E 38
	short	p_pgrp;		/* name of process group leader */
	short	p_pid;		/* unique process id */
	short	p_ppid;		/* process id of parent */
D 21
	short	p_poip;		/* count of page outs in progress */
	short	p_szpt;		/* copy of page table size */
E 21
I 21
D 25
	short	p_xstat;	/* Exit status for wait */
E 25
I 25
	u_short	p_xstat;	/* Exit status for wait */
E 25
	struct	rusage *p_ru;	/* mbuf holding exit information */
D 30
	short	p_poip;	/* page outs in progress */
	short	p_szpt;	/* copy of page table size */
E 30
I 30
	short	p_poip;		/* page outs in progress */
	short	p_szpt;		/* copy of page table size */
E 30
E 21
	size_t	p_tsize;	/* size of text (clicks) */
	size_t	p_dsize;	/* size of data space (clicks) */
	size_t	p_ssize;	/* copy of stack size (clicks) */
	size_t 	p_rssize; 	/* current resident set size in clicks */
I 15
	size_t	p_maxrss;	/* copy of u.u_limit[MAXRSS] */
E 15
	size_t	p_swrss;	/* resident set size before last swap */
	swblk_t	p_swaddr;	/* disk address of u area when swapped */
	caddr_t p_wchan;	/* event process is awaiting */
	struct	text *p_textp;	/* pointer to text structure */
D 21
	int	p_clktim;	/* time to alarm clock signal */
E 21
	struct	pte *p_p0br;	/* page table base P0BR */
I 36
D 39
	struct	pte *p_p1br;	/* page table base P1BR */
E 39
E 36
	struct	proc *p_xlink;	/* linked list of procs sharing same text */
D 8
	short	p_faults;	/* faults in last second */
	short	p_aveflt;	/* average of p_faults into past */
E 8
I 8
	short	p_cpticks;	/* ticks of cpu time */
	float	p_pctcpu;	/* %cpu for this process during p_time */
E 8
	short	p_ndx;		/* proc index for memall (because of vfork) */
	short	p_idhash;	/* hashed based on p_pid for kill+exit+... */
I 3
	struct	proc *p_pptr;	/* pointer to process structure of parent */
I 19
	struct	proc *p_cptr;	/* pointer to youngest living child */
	struct	proc *p_osptr;	/* pointer to older sibling processes */
	struct	proc *p_ysptr;	/* pointer to younger siblings */
I 26
	struct	itimerval p_realtimer;
I 30
	struct	quota *p_quota;	/* quotas for this process */
I 41
#if defined(tahoe)
	int	p_ckey;		/* code cache key */
	int	p_dkey;		/* data cache key */
#endif
E 41
E 30
I 29
D 32
#ifdef sun
	struct	context *p_ctx;	/* pointer to current context */
#endif
E 32
E 29
E 26
I 24
D 30
#ifdef QUOTA
E 24
	struct	quota *p_quota;	/* quotas for this process (MUSH) */
I 24
#endif
#ifdef MUSH
E 24
	mmsgbuf	p_mb;		/* pending message */
	int	p_msgflgs;	/* message flags */
I 24
#endif
E 30
E 24
I 21
D 26
	struct	itimerval p_realtimer;
E 26
I 22
D 23
	int	p_XXX;		/* XXX */
E 22
	struct	timeval p_seltimer;
E 23
I 23
D 24
	int	p_SSS[3];
E 24
E 23
E 21
E 19
E 3
};

D 35
#define	PIDHSZ		63
#define	PIDHASH(pid)	((pid) % PIDHSZ)
E 35
I 35
#define	PIDHSZ		64
#define	PIDHASH(pid)	((pid) & (PIDHSZ - 1))
E 35

#ifdef KERNEL
short	pidhash[PIDHSZ];
D 30

E 30
struct	proc *pfind();
D 30
#endif

#ifdef	KERNEL
E 30
D 13
extern	struct proc proc[];	/* the proc table itself */
E 13
I 13
D 14
extern	struct proc *proc, *procNPROC;	/* the proc table itself */
extern	int nproc;
E 14
I 14
struct	proc *proc, *procNPROC;	/* the proc table itself */
I 35
struct	proc *freeproc, *zombproc, *allproc;
			/* lists of procs in various states */
E 35
int	nproc;
E 14
E 13

D 12
#ifdef FASTVAX
E 12
#define	NQS	32		/* 32 run queues */
struct	prochd {
	struct	proc *ph_link;	/* linked list of running processes */
	struct	proc *ph_rlink;
} qs[NQS];
int	whichqs;		/* bit mask summarizing non-empty qs's */
D 12
#else
struct	proc *runq;
#endif
E 12
#endif

/* stat codes */
#define	SSLEEP	1		/* awaiting an event */
#define	SWAIT	2		/* (abandoned state) */
#define	SRUN	3		/* running */
#define	SIDL	4		/* intermediate state in process creation */
#define	SZOMB	5		/* intermediate state in process termination */
#define	SSTOP	6		/* process being traced */

/* flag codes */
D 6
#define	SLOAD	0x00001		/* in core */
#define	SSYS	0x00002		/* swapper or pager process */
#define	SLOCK	0x00004		/* process being swapped out */
#define	SSWAP	0x00008		/* save area flag */
#define	STRC	0x00010		/* process is being traced */
#define	SWTED	0x00020		/* another tracing flag */
#define	SULOCK	0x00040		/* user settable lock in core */
#define	SPAGE	0x00080		/* process in page wait state */
#define	SKEEP	0x00100		/* another flag to prevent swap out */
#define	SDLYU	0x00200		/* delayed unlock of pages */
#define	SWEXIT	0x00400		/* working on exiting */
#define	SPHYSIO	0x00800		/* doing physical i/o (bio.c) */
#define	SVFORK	0x01000		/* process resulted from vfork() */
#define	SVFDONE	0x02000		/* another vfork flag */
#define	SNOVM	0x04000		/* no vm, parent in a vfork() */
#define	SPAGI	0x08000		/* init data space on demand, from inode */
#define	SANOM	0x10000		/* system detected anomalous vm behavior */
#define	SUANOM	0x20000		/* user warned of anomalous vm behavior */
I 2
#define	STIMO	0x40000		/* timing out during sleep */
E 6
I 6
D 19
#define	SLOAD	0x000001	/* in core */
#define	SSYS	0x000002	/* swapper or pager process */
#define	SLOCK	0x000004	/* process being swapped out */
#define	SSWAP	0x000008	/* save area flag */
#define	STRC	0x000010	/* process is being traced */
#define	SWTED	0x000020	/* another tracing flag */
#define	SULOCK	0x000040	/* user settable lock in core */
#define	SPAGE	0x000080	/* process in page wait state */
#define	SKEEP	0x000100	/* another flag to prevent swap out */
#define	SDLYU	0x000200	/* delayed unlock of pages */
#define	SWEXIT	0x000400	/* working on exiting */
#define	SPHYSIO	0x000800	/* doing physical i/o (bio.c) */
#define	SVFORK	0x001000	/* process resulted from vfork() */
#define	SVFDONE	0x002000	/* another vfork flag */
#define	SNOVM	0x004000	/* no vm, parent in a vfork() */
#define	SPAGI	0x008000	/* init data space on demand, from inode */
D 16
#define	SANOM	0x010000	/* system detected anomalous vm behavior */
#define	SUANOM	0x020000	/* user warned of anomalous vm behavior */
E 16
I 16
#define	SSEQL	0x010000	/* user warned of sequential vm behavior */
#define	SUANOM	0x020000	/* user warned of random vm behavior */
E 16
#define	STIMO	0x040000	/* timing out during sleep */
E 19
I 19
#define	SLOAD	0x0000001	/* in core */
#define	SSYS	0x0000002	/* swapper or pager process */
#define	SLOCK	0x0000004	/* process being swapped out */
#define	SSWAP	0x0000008	/* save area flag */
#define	STRC	0x0000010	/* process is being traced */
#define	SWTED	0x0000020	/* another tracing flag */
#define	SULOCK	0x0000040	/* user settable lock in core */
#define	SPAGE	0x0000080	/* process in page wait state */
#define	SKEEP	0x0000100	/* another flag to prevent swap out */
D 28
#define	SDLYU	0x0000200	/* delayed unlock of pages */
E 28
I 28
D 31
/* was SDLYU */
E 31
I 31
#define	SOMASK	0x0000200	/* restore old mask after taking signal */
E 31
E 28
#define	SWEXIT	0x0000400	/* working on exiting */
#define	SPHYSIO	0x0000800	/* doing physical i/o (bio.c) */
#define	SVFORK	0x0001000	/* process resulted from vfork() */
#define	SVFDONE	0x0002000	/* another vfork flag */
#define	SNOVM	0x0004000	/* no vm, parent in a vfork() */
#define	SPAGI	0x0008000	/* init data space on demand, from inode */
#define	SSEQL	0x0010000	/* user warned of sequential vm behavior */
#define	SUANOM	0x0020000	/* user warned of random vm behavior */
#define	STIMO	0x0040000	/* timing out during sleep */
E 19
D 18
#define	SDETACH	0x080000	/* detached inherited by init */
E 18
I 18
/* was SDETACH */
E 18
D 19
#define	SNUSIG	0x100000	/* using new signal mechanism */
I 10
#define	SOWEUPC	0x200000	/* owe process an addupc() call at next ast */
I 17
#define	SSEL	0x400000	/* selecting; wakeup/waiting danger */
E 19
I 19
D 31
#define	SNUSIG	0x0100000	/* using new signal mechanism */
E 31
I 31
#define	SOUSIG	0x0100000	/* using old signal mechanism */
E 31
D 21
#define	SOWEUPC	0x0200000	/* owe process an addupc() call at next ast */
E 21
I 21
D 27
/* unused */
E 27
I 27
#define	SOWEUPC	0x0200000	/* owe process an addupc() call at next ast */
E 27
E 21
#define	SSEL	0x0400000	/* selecting; wakeup/waiting danger */
#define	SLOGIN	0x0800000	/* a login process (legit child of init) */
I 25
#define	SPTECHG	0x1000000	/* pte's for process have changed */
E 25
E 19
E 17
E 10
E 6
E 2
D 21

/*
 * parallel proc structure
 * to replace part with times
 * to be passed to parent process
 * in ZOMBIE state.
 *
 * THIS SHOULD BE DONE WITH A union() CONSTRUCTION
 */
struct	xproc
{
	struct	proc *xp_link;
	struct	proc *xp_rlink;
	struct	pte *xp_addr;
	char	xp_usrpri;
	char	xp_pri;		/* priority, negative is high */
	char	xp_cpu;		/* cpu usage for scheduling */
	char	xp_stat;
	char	xp_time;	/* resident time for scheduling */
	char	xp_nice;	/* nice for cpu usage */
	char	xp_slptime;
D 3
	int	xp_flag;
E 3
I 3
	char	p_cursig;
E 3
	int	xp_sig;		/* signals pending to this process */
D 3
	int	xp_ignsig;
E 3
I 3
	int	xp_siga0;
	int	xp_siga1;
	int	xp_flag;
E 3
	short	xp_uid;		/* user id, used to direct tty signals */
	short	xp_pgrp;	/* name of process group leader */
	short	xp_pid;		/* unique process id */
	short	xp_ppid;	/* process id of parent */
	short	xp_xstat;	/* Exit status for wait */
	struct	vtimes xp_vm;
};
E 21
E 1
