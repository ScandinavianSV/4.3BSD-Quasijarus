h22685
s 00009/00028/00105
d D 6.3 86/04/23 23:37:06 mckusick 5 4
c update from Ken Arnold
e
s 00038/00016/00095
d D 6.2 86/04/15 15:35:25 mckusick 4 3
c from Ken Arnold
e
s 00001/00001/00110
d D 6.1 85/05/15 15:23:48 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00012/00016/00099
d D 5.1 85/05/15 15:23:20 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00115/00000/00000
d D 4.1 85/05/15 15:22:50 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\"	%W% (Berkeley) %G%
.\"
D 2
.TH CURSES 3
E 2
I 2
D 3
.TH CURSES 3X "19 January 1983"
E 3
I 3
.TH CURSES 3X "%Q%"
E 3
E 2
.UC 4
.SH NAME
curses \- screen functions with ``optimal'' cursor motion
.SH SYNOPSIS
I 4
D 5
.B # include <curses.h>
.sp
E 5
E 4
.B cc
D 4
[ flags ] files
E 4
I 4
D 5
\&...
E 5
I 5
[ flags ] files
E 5
E 4
.B \-lcurses \-ltermcap
I 5
[ libraries ]
E 5
D 4
[ libraries ]
E 4
.SH DESCRIPTION
D 2
These routines give the user a method
of updating screens with reasonable optimization.
They keep an image of the current screen,
and the user sets up an image of a new one.
Then the
E 2
I 2
These routines give the user a method of updating screens with reasonable
optimization.  They keep an image of the current screen,
and the user sets up an image of a new one.  Then the
E 2
.I refresh()
D 2
tells the routines to make the current screen look
like the new one.
In order to initialize the routines,
the routine
E 2
I 2
tells the routines to make the current screen look like the new one.
In order to initialize the routines, the routine
E 2
.I initscr()
D 2
must be called before any of the other routines
that deal with windows and screens
are used.
The routine
E 2
I 2
must be called before any of the other routines that deal with windows and
screens are used.  The routine
E 2
.I endwin()
D 4
should be called before exiting.
E 4
I 4
D 5
should always called before exiting.
E 5
I 5
should be called before exiting.
E 5
E 4
.SH SEE ALSO
.I "Screen Updating and Cursor Movement Optimization: A Library Package,"
Ken Arnold,
.br
D 2
stty(2),
setenv(3),
E 2
I 2
ioctl(2),
getenv(3),
tty(4),
E 2
termcap(5)
.SH AUTHOR
Ken Arnold
.SH FUNCTIONS
.nf
D 4
.ds w \fIwin\fR
.ds s \fIstdscr\fR
E 4
I 4
.ds w \fIwin\fP
.ds s \fIstdscr\fP
D 5
.ds yx (\fIy\fP,\fIx\fP\|)
E 5
E 4
.ta 3i
addch(ch)	add a character to \*s
addstr(str)	add a string to \*s
box(win,vert,hor)	draw a box around a window
D 4
crmode()	set cbreak mode
E 4
I 4
D 5
baudrate()	return current baud rate
E 5
cbreak()	set cbreak mode
E 4
clear()	clear \*s
D 4
clearok(scr,boolf)	set clear flag for \fIscr\fR
E 4
I 4
clearok(scr,boolf)	set clear flag for \fIscr\fP
E 4
clrtobot()	clear to bottom on \*s
clrtoeol()	clear to end of line on \*s
delch()	delete a character
deleteln()	delete a line
delwin(win)	delete \*w
echo()	set echo mode
endwin()	end window modes
erase()	erase \*s
I 4
D 5
erasechar()	return user's erase char
flusok(win,boolf)	set flush-on-refresh flag for \*w
fullname(termbuf,name)	get full name from \fItermbuf\fP
E 5
I 5
flusok(win,boolf)	set flush-on-refresh flag for \fIwin\fP
E 5
E 4
getch()	get a char through \*s
D 4
getcap(name)	get terminal capability \fIname\fR
E 4
I 4
getcap(name)	get terminal capability \fIname\fP
E 4
getstr(str)	get a string through \*s
gettmode()	get tty modes
D 4
getyx(win,y,x)	get (y,x) co-ordinates
inch()	get char at current (y,x) co-ordinates
E 4
I 4
D 5
getyx(win,y,x)	get \*(yx co-ordinates
idlok(win,boolf)	set use-insert/delete-line for \*w
inch()	get char at current \*(yx co-ordinates
E 5
I 5
getyx(win,y,x)	get (y,x) co-ordinates
inch()	get char at current (y,x) co-ordinates
E 5
E 4
initscr()	initialize screens
insch(c)	insert a char
insertln()	insert a line
I 4
D 5
killchar()	return user's kill char
E 5
E 4
leaveok(win,boolf)	set leave flag for \*w
D 4
longname(termbuf,name)	get long name from \fItermbuf\fR
move(y,x)	move to (y,x) on \*s
E 4
I 4
longname(termbuf,name)	get long name from \fItermbuf\fP
D 5
move(y,x)	move to \*(yx on \*s
E 5
I 5
move(y,x)	move to (y,x) on \*s
E 5
E 4
mvcur(lasty,lastx,newy,newx)	actually move cursor
I 4
D 5
mvwin(win,y,x)	move \*w pos to \*(yx
E 5
E 4
newwin(lines,cols,begin_y,begin_x)\ 	create a new window
nl()	set newline mapping
D 4
nocrmode()	unset cbreak mode
E 4
I 4
nocbreak()	unset cbreak mode
E 4
noecho()	unset echo mode
nonl()	unset newline mapping
noraw()	unset raw mode
overlay(win1,win2)	overlay win1 on win2
overwrite(win1,win2)	overwrite win1 on top of win2
printw(fmt,arg1,arg2,...)	printf on \*s
raw()	set raw mode
refresh()	make current screen look like \*s
resetty()	reset tty flags to stored value
savetty()	stored current tty flags
scanw(fmt,arg1,arg2,...)	scanf through \*s
scroll(win)	scroll \*w one line
scrollok(win,boolf)	set scroll flag
setterm(name)	set term variables for name
standend()	end standout mode
standout()	start standout mode
subwin(win,lines,cols,begin_y,begin_x)\ 	create a subwindow
I 4
touchline(win,y,sx,ex)	mark line \fIy\fP \fIsx\fP through \fIsy\fP as changed
touchoverlap(win1,win2)	mark overlap of \fIwin1\fP on \fIwin2\fP as changed
E 4
touchwin(win)	\*(lqchange\*(rq all of \*w
D 4
unctrl(ch)	printable version of \fIch\fR
E 4
I 4
unctrl(ch)	printable version of \fIch\fP
E 4
waddch(win,ch)	add char to \*w
waddstr(win,str)	add string to \*w
wclear(win)	clear \*w
wclrtobot(win)	clear to bottom of \*w
wclrtoeol(win)	clear to end of line on \*w
wdelch(win,c)	delete char from \*w
wdeleteln(win)	delete line from \*w
werase(win)	erase \*w
wgetch(win)	get a char through \*w
wgetstr(win,str)	get a string through \*w
D 4
winch(win)	get char at current (y,x) in \*w
E 4
I 4
D 5
winch(win)	get char at current \*(yx in \*w
E 5
I 5
winch(win)	get char at current (y,x) in \*w
E 5
E 4
winsch(win,c)	insert char into \*w
winsertln(win)	insert line into \*w
D 4
wmove(win,y,x)	set current (y,x) co-ordinates on \*w
E 4
I 4
D 5
wmove(win,y,x)	set current \*(yx co-ordinates on \*w
E 5
I 5
wmove(win,y,x)	set current (y,x) co-ordinates on \*w
E 5
E 4
wprintw(win,fmt,arg1,arg2,...)\ 	printf on \*w
wrefresh(win)	make screen look like \*w
wscanw(win,fmt,arg1,arg2,...)\ 	scanf through \*w
wstandend(win)	end standout mode on \*w
wstandout(win)	start standout mode on \*w
I 2
.SH BUGS
I 4
D 5
.PP
.IR getch() ,
.IR getstr() ,
and
.IR scanw()
have been rarely used,
and are probably buggy.
.PP
Insert/delete line and char sequences
are not used as often as they should be,
and scrolling regions are not used at all.
E 5
E 4
E 2
E 1
